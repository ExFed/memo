//! # Memo - Command Memoization Tool
//!
//! Memo is a command-line tool that memoizes (caches) shell command execution results.
//! When you run a command through memo, it stores the stdout, stderr, and exit code.
//! Subsequent executions of the same command will replay the cached results instantly
//! without re-running the command.
//!
//! ## How It Works
//!
//! - **Cache Key**: SHA-256 hash of the command arguments and current working directory
//! - **Storage**: Each memoized command is stored in a subdirectory:
//!   - `<digest>/meta.json` - Metadata (command, exit code, timestamp)
//!   - `<digest>/stdout` - Captured stdout
//!   - `<digest>/stderr` - Captured stderr
//! - **Location**: `$XDG_CACHE_HOME/memo/` (defaults to `~/.cache/memo/`)
//!
//! ## Usage Examples
//!
//! ```bash
//! # First run executes the command
//! memo echo "Hello, World!"
//!
//! # Second run replays from cache (instant)
//! memo echo "Hello, World!"
//!
//! # Verbose mode shows cache hits/misses
//! memo -v ls -la /etc
//!
//! # Commands with different arguments create separate cache entries
//! memo echo "foo"
//! memo echo "bar"
//! ```
//!
//! ## Features
//!
//! - Preserves exact stdout, stderr, and exit codes
//! - Handles binary data correctly
//! - Streaming architecture for memory efficiency
//! - Atomic directory-based concurrency control (lock-free)
//! - Secure file permissions on Unix systems

mod cache;
mod constants;
mod digest;
mod error;
mod executor;
mod memo;

use cache::{
    cleanup_temp_dirs, commit_cache_dir, create_temp_cache_dir, ensure_cache_dir, get_cache_dir,
    is_memo_disabled, memo_complete, read_memo_metadata, stream_stderr, stream_stdout,
};
use chrono::Utc;
use clap::Parser;
use digest::compute_digest_for_args;
use error::Result;
use executor::{build_command_string, execute_and_stream, execute_direct};
use memo::Memo;
use std::fs;
use std::io::{self, Write};
use std::process;

#[derive(Parser, Debug)]
#[command(name = "memo")]
#[command(about = "Memoize shell command execution", long_about = None)]
#[command(after_help = "** SECURITY WARNING **\n\n\
    Memoization caches stdout/stderr to disk UNENCRYPTED. Do NOT use memo with commands \
that output sensitive information such as:\n\
    - Authentication tokens or API keys\n\
    - Passwords or credentials\n\
    - Private keys or certificates\n\
    - Personally identifiable information\n\n\
    Cached files are stored in ~/.cache/memo/ and may be accessible to other users on shared systems.\n\
    Use MEMO_DISABLE=1 to bypass caching for individual commands with sensitive output.")]
struct Cli {
    /// Print memoization information
    #[arg(short, long)]
    verbose: bool,

    /// Command to execute/memoize
    #[arg(trailing_var_arg = true, required = true, allow_hyphen_values = true)]
    command: Vec<String>,
}

fn main() {
    if let Err(e) = run() {
        eprintln!(":: memo :: ERROR: {}", e);
        process::exit(1);
    }
}

fn run() -> Result<()> {
    let args = Cli::parse();

    // Check if memoization is disabled
    if is_memo_disabled() {
        if args.verbose {
            eprintln!(":: memo :: disabled");
        }

        // Convert Vec<String> to Vec<&str>
        let cmd_args: Vec<&str> = args.command.iter().map(|s| s.as_str()).collect();

        // Execute directly without caching
        let result = execute_direct(&cmd_args)?;
        process::exit(result.exit_code);
    }

    // Get cache directory
    let cache_dir = get_cache_dir()?;
    ensure_cache_dir(&cache_dir)?;

    // Clean up any orphaned temp directories from previous crashes
    cleanup_temp_dirs(&cache_dir)?;

    // Get current working directory
    let cwd = std::env::current_dir()?.to_string_lossy().to_string();

    // Build command string for display and compute digest from argv.
    let command_string = build_command_string(&args.command);
    let digest = compute_digest_for_args(&args.command, &cwd)?;

    // Check if memo exists
    if memo_complete(&cache_dir, &digest) {
        // Cache hit - replay
        if args.verbose {
            eprintln!(":: memo :: hit `{command_string}` => {digest}");
        }

        // Read metadata
        let memo = read_memo_metadata(&cache_dir, &digest)?;

        // Stream output to stdout/stderr
        stream_stdout(&cache_dir, &digest, io::stdout())?;
        stream_stderr(&cache_dir, &digest, io::stderr())?;

        // Exit with stored exit code
        process::exit(memo.exit_code);
    } else {
        // Cache miss - execute and memoize
        if args.verbose {
            eprintln!(":: memo :: miss `{command_string}` => {digest}");
        }

        let timestamp = Utc::now().to_rfc3339();

        // Create a temp directory for this process to write cache files
        let mut temp_dir = create_temp_cache_dir(&cache_dir, &digest)?;
        let (json_path, out_path, err_path) = temp_dir.get_paths();

        // Convert Vec<String> to Vec<&str>
        let cmd_args: Vec<&str> = args.command.iter().map(|s| s.as_str()).collect();

        // Execute command and stream to files AND console simultaneously
        let result = execute_and_stream(&cmd_args, &out_path, &err_path)?;

        // Report any file write errors
        if let Some(path) = &result.stdout_error {
            eprintln!(":: memo :: ERROR: could not write {}", path.display());
        }
        if let Some(path) = &result.stderr_error {
            eprintln!(":: memo :: ERROR: could not write {}", path.display());
        }

        // Create memo metadata
        let memo = Memo {
            cmd: args.command.clone(),
            cwd: cwd.clone(),
            exit_code: result.exit_code,
            timestamp,
            digest: digest.clone(),
        };

        // Write metadata to JSON
        let json = serde_json::to_string_pretty(&memo)?;
        {
            let mut f = fs::File::create(&json_path)?;
            f.write_all(json.as_bytes())?;
        }

        // Atomically commit the temp directory to the final location
        // If another process already committed, that's fine - we just clean up
        let _ = commit_cache_dir(&mut temp_dir, &cache_dir, &digest);

        // Exit with command's exit code (output already streamed to console)
        process::exit(result.exit_code);
    }
}
